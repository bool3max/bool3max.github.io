<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bool3max&#39;s blog</title>
    <link>https://bool3max.github.io/</link>
    <description>bool3max&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 28 Sep 2020 15:45:48 +0200</lastBuildDate>
    
    <atom:link href="https://bool3max.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Why I prefer fish over bash for scripting</title>
      <link>https://bool3max.github.io/posts/fish_scripting_over_bash/</link>
      <pubDate>Mon, 28 Sep 2020 15:45:48 +0200</pubDate>
      
      <guid>https://bool3max.github.io/posts/fish_scripting_over_bash/</guid>
      <description>&lt;p&gt;Scripting with &lt;a href=&#34;https://github.com/fish-shell/fish-shell&#34;&gt;&lt;code&gt;fish&lt;/code&gt;&lt;/a&gt; is simple. It is readable. You don&amp;rsquo;t need to have deep experience with it in order to understand the syntax.&lt;/p&gt;
&lt;p&gt;Compared to &lt;code&gt;bash&lt;/code&gt;, it feels &lt;em&gt;intuitive&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;everything-is-a-builtin&#34;&gt;Everything is a builtin&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;builtins&lt;/code&gt; are commands that you call from the shell, but unlike regular commands that execute external binaries and spawn new processes, they are built right into the shell (e.g. &lt;code&gt;echo&lt;/code&gt;, &lt;code&gt;math&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;The core syntax of &lt;code&gt;fish&lt;/code&gt; is very simple, and most all of the operations are done via calling builtins.&lt;/p&gt;
&lt;p&gt;Want to set a variable? Use the &lt;code&gt;set&lt;/code&gt; builtin. Want to declare a function? Use the &lt;code&gt;function&lt;/code&gt; builtin. Want perform some sort of calculation? Use the &lt;code&gt;math&lt;/code&gt; builtin. Want to find out what some other builtin does? Use the &lt;code&gt;help&lt;/code&gt; builtin.&lt;/p&gt;
&lt;p&gt;In fact, prior to &lt;code&gt;fish 3.0&lt;/code&gt;, even conditional command execution was done using &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; builtins (&lt;em&gt;unconditional&lt;/em&gt; command chaining is still done using the seimicolon &lt;code&gt;;&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git commit; and git push
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(it still is, though support for &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; syntax was added).&lt;/p&gt;
&lt;h3 id=&#34;string-replacement&#34;&gt;String replacement&lt;/h3&gt;
&lt;p&gt;In &lt;code&gt;bash&lt;/code&gt;, string replacement is done using the &lt;code&gt;${$text//pattern/replacement}&lt;/code&gt; syntax. For example, if you wanted to replace every instance of &lt;code&gt;&#39;foo&#39;&lt;/code&gt; with &lt;code&gt;&#39;bar&#39;&lt;/code&gt; in a certain text, you could do it like so:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;replaced_text&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;$text//foo/bar&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In &lt;code&gt;fish&lt;/code&gt;, however, this is done using the &lt;code&gt;string&lt;/code&gt; builtin:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;set replaced_text &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;string replace -a foo bar $text&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;array-item-count&#34;&gt;Array item count&lt;/h3&gt;
&lt;p&gt;In &lt;code&gt;fish&lt;/code&gt;, getting the number of items in an array is done using the &lt;code&gt;count&lt;/code&gt; builtin:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;set N &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;count $array&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In &lt;code&gt;bash&lt;/code&gt;, the syntax is, to no surprise, more obscure:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;N&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${#&lt;/span&gt;args[@]&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;math&#34;&gt;Math&lt;/h3&gt;
&lt;p&gt;In &lt;code&gt;fish&lt;/code&gt;, mathematical operations are peformed using the &lt;code&gt;math&lt;/code&gt; builtin, and unlike in bash, they support decimal numbers as well as functions:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;3 + sqrt(4) = &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;math &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; + &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;sqrt(4)&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;

&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; + sqrt&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;4&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Since &lt;code&gt;bash&lt;/code&gt; doesn&amp;rsquo;t support decimal operations nor mathematical functions, you&amp;rsquo;d have to call external processes to do the work for you.&lt;/p&gt;
&lt;p&gt;For someone who isn&amp;rsquo;t familiar with shell scripting, the &lt;code&gt;fish&lt;/code&gt; versions of these example operations are going to make much more sense at first (and probably second) glance.&lt;/p&gt;
&lt;p&gt;This philosophy makes scripts insanely &lt;em&gt;readable&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;argument-substitution-is-more-intuitive&#34;&gt;Argument substitution is more intuitive&lt;/h2&gt;
&lt;p&gt;This was one of my first serious gripes back when I was first learning &lt;code&gt;bash&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s assume that &lt;code&gt;barg&lt;/code&gt; is a readily available program that simply prints its commandline arguments (as well as the number of them), to standard out, one per line:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ barg &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;

User arguments passed: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;

&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Parameter substition in &lt;code&gt;fish&lt;/code&gt; &lt;em&gt;makes sense&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Expanding a single variable results in a &lt;em&gt;&lt;strong&gt;single argument&lt;/strong&gt;&lt;/em&gt; on the commandline. For example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ set arg &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello there, you!&amp;#34;&lt;/span&gt;
$ barg $arg

User arguments passed: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;

Hello there, you!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It is only if you pass in an array of &lt;em&gt;multiple values&lt;/em&gt;, that the resulting commandline ends up with multiple values, for example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ set args &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello there, you!&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;--some-long-option&amp;#34;&lt;/span&gt;
$ barg $args

User arguments passed: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;

Hello there, you!
--some-long-option
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Again, it is intuitive and it makes sense.&lt;/p&gt;
&lt;p&gt;Now let&amp;rsquo;s take a look at the same examples, but in &lt;code&gt;bash&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ arg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello there, you!&amp;#34;&lt;/span&gt;
$ barg $arg

User arguments passed: &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;

Hello
there,
you!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The source operand was split on spaces, and a single variable substitution resulted in &lt;em&gt;3&lt;/em&gt; different commandline arguments.&lt;/p&gt;
&lt;p&gt;To avoid this, you have to encapsulate substituion in double quotes (&lt;code&gt;&amp;quot; &amp;quot;&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ arg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello there, you!&amp;#34;&lt;/span&gt;
$ barg &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$args&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;

User arguments passed: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;

Hello there, you!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To me this makes no sense, however from a historical point of view I can see why it is: in &lt;code&gt;fish&lt;/code&gt;, declaring arrays of multiple values each of which expands to a signle value is easy, unlike in &lt;code&gt;bash&lt;/code&gt;, where, if you&amp;rsquo;d written something like &lt;code&gt;arguments=&amp;quot;-a -D --long-opt&amp;quot;&lt;/code&gt;, you would probably in fact &lt;em&gt;want&lt;/em&gt; it to expand to 3 different arguments.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;These are just some of the examples. The true strength of &lt;code&gt;fish&lt;/code&gt; lies in its power as an interactive shell - robust automatic completion, autosuggestions, configurability, colors, etc&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Understanding the ELF file structure</title>
      <link>https://bool3max.github.io/posts/elf/</link>
      <pubDate>Sun, 09 Aug 2020 18:54:26 +0200</pubDate>
      
      <guid>https://bool3max.github.io/posts/elf/</guid>
      <description>&lt;p&gt;I recently took it upon myself to, at least at the surface level, understand how the ELF (&amp;quot;&lt;em&gt;Executable and Linkable Format&lt;/em&gt;&amp;quot;) works.
In order to do that, I set out to create a tiny python3 module for parsing (meta-)data out of ELF files.&lt;/p&gt;
&lt;p&gt;The result of that is &lt;a href=&#34;https://github.com/bool3max/p3elf&#34;&gt;&lt;strong&gt;p3elf&lt;/strong&gt;&lt;/a&gt;, during the development of which I familiarized myself with ELF, binary IO in python, as well as &lt;code&gt;setuptools&lt;/code&gt; and publishing python packages on &lt;a href=&#34;https://pypi.org/project/p3elf&#34;&gt;PyPI&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This post will mainly serve as a short future reference of the structure of ELF files and will most likely be updated in the future.&lt;/p&gt;
&lt;h1 id=&#34;structure&#34;&gt;Structure&lt;/h1&gt;
&lt;p&gt;The &lt;a href=&#34;https://en.wikipedia.org/wiki/Executable_and_Linkable_Format&#34;&gt;Executable and Linkable Format&lt;/a&gt; Wikipedia article is an excellent reference for the structure and fields of ELF files, though I found it to be a little ambiguous in certain places. Some concepts are not completely obvious unless you have prior experience with ELF.&lt;/p&gt;
&lt;h2 id=&#34;file-header&#34;&gt;File header&lt;/h2&gt;
&lt;p&gt;Every ELF file begins with a &lt;strong&gt;file header&lt;/strong&gt;. It contains general metadata about the binary, and its size is known in advance - it is &lt;code&gt;64&lt;/code&gt; bytes long on 64bit binaries, and &lt;code&gt;56&lt;/code&gt; bytes long on 32bit ones.&lt;/p&gt;
&lt;p&gt;Notable fields here include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;EI_CLASS&lt;/code&gt;&lt;/strong&gt;: denotes the &lt;em&gt;byteclass&lt;/em&gt; of the binary (&lt;code&gt;0x1&lt;/code&gt;: 32bit, &lt;code&gt;0x2&lt;/code&gt;: 64bit)
&lt;ul&gt;
&lt;li&gt;this field is particularly important because the lengths and offsets of many other fields in the file depend on it&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;EI_DATA&lt;/code&gt;&lt;/strong&gt;: denotes the &lt;em&gt;endianness&lt;/em&gt; of the binary
&lt;ul&gt;
&lt;li&gt;important for the same reasons as EI_CLASS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;EI_OSABI&lt;/code&gt;&lt;/strong&gt;: denotes the &lt;em&gt;ABI&lt;/em&gt;, but is often set to &lt;code&gt;0x0&lt;/code&gt; (&lt;em&gt;System V&lt;/em&gt;) regardless of the actual platform&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;E_TYPE&lt;/code&gt;&lt;/strong&gt;: type of object file (executable, relocatable, etc.)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;E_MACHINE&lt;/code&gt;&lt;/strong&gt;: denotes the target ISA, e.g. &lt;code&gt;0x3E&lt;/code&gt; for &lt;code&gt;&#39;amd64&#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;E_PHOFF&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;E_SHOFF&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;E_PHOFF&lt;/code&gt;&lt;/strong&gt;,  &lt;strong&gt;&lt;code&gt;E_SHNUM&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;E_PHNUM&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;E_SHENTSIZE&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;E_PHENTSIZE&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;offsets, counts, and sizes of &lt;strong&gt;section headers&lt;/strong&gt; and &lt;strong&gt;program headers&lt;/strong&gt; - more on these later&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;segments--program-headers&#34;&gt;Segments &amp;amp; Program headers&lt;/h2&gt;
&lt;p&gt;Every ELF file is divided into &lt;em&gt;segments&lt;/em&gt;, which are further divided into one or more &lt;em&gt;sections&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Every program header corresponds to one segment and provides info and metadata about it. Because of that, we know the number of segments in advance - it&amp;rsquo;s the &lt;strong&gt;&lt;code&gt;E_PHNUM&lt;/code&gt;&lt;/strong&gt; field in the file header.&lt;/p&gt;
&lt;p&gt;The first segment is the &amp;ldquo;program header table&amp;rdquo; - i.e. the segment that contains all of the program headers (which in turn describe other segments).&lt;/p&gt;
&lt;p&gt;The first program header (&lt;code&gt;PT_TYPE&lt;/code&gt; 0x00000006, i.e. &lt;code&gt;PT_PHDR&lt;/code&gt;) (the one that describes the entire program header table segment) is found at offset &lt;strong&gt;&lt;code&gt;E_PHOFF&lt;/code&gt;&lt;/strong&gt; and is &lt;strong&gt;&lt;code&gt;E_PHENTSIZE&lt;/code&gt;&lt;/strong&gt; bytes long. Because every program header is the same size, and because they all follow the first one (of which we know the offset), we can traverse through them pretty easily.&lt;/p&gt;
&lt;p&gt;Notable fields in every program header include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;P_TYPE&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;the type of segment that this header describes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;P_OFFSET&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;the offset from the beginning of the file to the &lt;em&gt;segment&lt;/em&gt; that this header describes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;P_FILESZ&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;the size of the segment that this header describes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;P_FLAGS&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;segment-specific flags that provide additional information about the segment that this header describes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sections--section-headers&#34;&gt;Sections &amp;amp; Section headers&lt;/h2&gt;
&lt;p&gt;Every one of the aforementioned segments consists of one or more &lt;em&gt;sections&lt;/em&gt;, each of which is associated with a &lt;em&gt;section header&lt;/em&gt; that describes it.&lt;/p&gt;
&lt;p&gt;The first section header is found at offset &lt;strong&gt;&lt;code&gt;E_SHOFF&lt;/code&gt;&lt;/strong&gt;, and is &lt;strong&gt;&lt;code&gt;E_SHENTSIZE&lt;/code&gt;&lt;/strong&gt; bytes long. It is always &amp;ldquo;empty&amp;rdquo; - its &lt;code&gt;SH_TYPE&lt;/code&gt; is 0x0 (i.e. &lt;code&gt;SHT_NULL&lt;/code&gt;) and it doesn&amp;rsquo;t point to any section.&lt;/p&gt;
&lt;p&gt;There are &lt;strong&gt;&lt;code&gt;E_SHNUM&lt;/code&gt;&lt;/strong&gt; section headers, from which we can conduct that there are also &lt;strong&gt;&lt;code&gt;E_SHNUM&lt;/code&gt;&lt;/strong&gt; sections.&lt;/p&gt;
&lt;p&gt;Notable fields in every section header include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SH_NAME&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;an offset to a null-terminated string in the &lt;strong&gt;&lt;code&gt;.shstrtab&lt;/code&gt;&lt;/strong&gt; section denoting the section&amp;rsquo;s name&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;.shstrtab&lt;/code&gt;&lt;/strong&gt; is a special section (that has its own section header, like any other) that contains null terminating strings describing the names of all other sections&lt;/li&gt;
&lt;li&gt;programs can use the &lt;code&gt;EI_SHSTRNDX&lt;/code&gt; (the integer index of the &lt;code&gt;.shstrndx&lt;/code&gt; section, where 0 &amp;lt; &lt;code&gt;EI_SHSTRNDX&lt;/code&gt; &amp;lt; (&lt;code&gt;EI_SHNUM&lt;/code&gt; - 1) ) field in the file header to easily seek to this section&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SH_TYPE&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;the type of the section that this headers describes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SH_FLAGS&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;addtional attributes about the section&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SH_OFFSET&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;the offset from the beginning of the file to the section that this header describes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SH_SIZE&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;the size of this section&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SH_ENTSIZE&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;size of each entry in this section, for sections that have dynamic entries, otherwise &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;for example, this field is set to &lt;code&gt;0&lt;/code&gt; in the header that describes the &lt;code&gt;.shstrab&lt;/code&gt; section as it contains null-terminating strings of varying lengths&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;SH_LINK&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;section index of an associated section (its use depends on the type of section that this header describes)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Famous examples of &lt;em&gt;sections&lt;/em&gt; include &lt;strong&gt;.text&lt;/strong&gt; (actual executable instructions), &lt;strong&gt;.data&lt;/strong&gt;, &lt;strong&gt;.rodata&lt;/strong&gt; (read-only data), &lt;strong&gt;.symtab&lt;/strong&gt; (the symbol table) and others. There may also exist platform-specific sections, for example a really cool one produced by binutils&#39; &lt;code&gt;ld&lt;/code&gt; linker, &lt;code&gt;.note.gnu.build-id&lt;/code&gt;, which is a sha1/md5 hash of the output file. Or &lt;code&gt;.comment&lt;/code&gt;, which includes the version of the GCC stack that was used to build the ELF.&lt;/p&gt;
&lt;h2 id=&#34;tools-and-references&#34;&gt;Tools and references&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;the best tools to use for interacting with ELF files are &lt;code&gt;readelf&lt;/code&gt;, &lt;code&gt;objdump&lt;/code&gt;, and &lt;code&gt;size&lt;/code&gt;. They are all part of GNU&amp;rsquo;s &lt;a href=&#34;https://www.gnu.org/software/binutils/&#34;&gt;&lt;code&gt;binutils&lt;/code&gt;&lt;/a&gt; so you most likely already have them installed.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sco.com/developers/gabi/latest/contents.html&#34;&gt;SysV ABI Specification DRAFT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/tagged/elf&#34;&gt;ELF tag on StackOverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Executable_and_Linkable_Format&#34;&gt;Executable and Linkable Format - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/eliben/pyelftools&#34;&gt;&lt;code&gt;pyelftools&lt;/code&gt; on GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
    </item>
    
    <item>
      <title>Type Conversion and Declarations in C</title>
      <link>https://bool3max.github.io/posts/c_tc_and_decl/</link>
      <pubDate>Wed, 14 Nov 2018 18:05:02 +0200</pubDate>
      
      <guid>https://bool3max.github.io/posts/c_tc_and_decl/</guid>
      <description>&lt;p&gt;This document explains the rules of type conversion, declarations, as well as object properties described in the C standard. It is not meant to be read as a tutorial, but rather as a quick reference.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;type-conversion&#34;&gt;Type Conversion&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Implicit conversion&lt;/strong&gt; - any type conversion done by the compiler, which does not involve casting (e.g. assignment conversion, or usual arithmetic conversion &amp;ndash; conversion done upon non-equivalent types of operands with binary operators, or perhaps mismatch return type from a function or a function parameter/argument) &amp;ndash; &lt;strong&gt;RULES:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;integer ranks&lt;/strong&gt; (excluding extended and enumerated types):
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;long long int, unsigned long long int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long int, unsigned long int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int, unsigned int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;short int, unsigned short int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char, singed char, unsigned char&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_Bool&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;integer promotion&lt;/strong&gt;: convert any type whose rank is less than &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;unsigned int&lt;/code&gt; to &lt;code&gt;int&lt;/code&gt; (provided it can fit) or else &lt;code&gt;unsigned int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Usual arithmetic conversions&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;either operand is floating type&lt;/em&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;float -&amp;gt; double -&amp;gt; long double&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;convert the other operand to the same floating type&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;neither operand is a floating type&lt;/em&gt;:
&lt;ul&gt;
&lt;li&gt;First, perform integer promotion on both operands&lt;/li&gt;
&lt;li&gt;If types of both operands are now the same, &lt;strong&gt;the process ends, if not&lt;/strong&gt;, perform the following rules, and stop at the first one that applies
&lt;ol&gt;
&lt;li&gt;If both operands have &lt;code&gt;signed&lt;/code&gt; types or if both operands have &lt;code&gt;unsigned&lt;/code&gt; types, convert the operand whose type rank is lower to the type of the operand whose type rank is higher&lt;/li&gt;
&lt;li&gt;If the operand with the unsigned type has a rank HIGHER or EQUAL to the rank of the signed operand, convert the operand with the singed type to the type of the operand with the unsigned type&lt;/li&gt;
&lt;li&gt;If the operand with the signed type can represent all of the values of the type with the unsigned operand, convert the unsigned operand to the type of the signed operand&lt;/li&gt;
&lt;li&gt;If none of the above rules apply, convert BOTH operands to the &lt;code&gt;unsigned&lt;/code&gt; &amp;ldquo;version&amp;rdquo; of the type of the signed operand&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Assignment conversion&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;The usual arithmetic conversion rules do not apply here. In assignment conversion, the value of the expression on the right is simply converted to the type of the object on the left. An overflow can happen if the value of the expression on the right is too large to be represented using the type of the object on the left. (&lt;em&gt;side&lt;/em&gt; here represents the left/rights sides of the &lt;code&gt;=&lt;/code&gt; operator)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Explicit conversion&lt;/strong&gt; - type conversion done using casts&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;declarations&#34;&gt;Declarations&lt;/h2&gt;
&lt;p&gt;Before we begin, we have to understand that every object in C has &lt;strong&gt;3&lt;/strong&gt; properties. These are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Storage duration&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;It determines when the memory for the object is allocted, and when it is realeased/freed.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Storage for objects with &lt;strong&gt;automatic storage duration&lt;/strong&gt; is allocated when the block containing the object is entered, and it is deallocated when the block containing the object is terminated.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;An object with &lt;strong&gt;static storage duration&lt;/strong&gt; stays at the same storage duration as long as the program is running, allowing it to keep its value indefinitely. All objects declared with static storage duration and without an explicit initializer are &lt;strong&gt;zeroed-out&lt;/strong&gt; (be that inside a block using &lt;code&gt;static&lt;/code&gt;, or at file scope without a storage class)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Scope&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The scope of the object determines the portion of the program from which the object can be referenced.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Block scope&lt;/strong&gt;: The object is &amp;ldquo;visible&amp;rdquo; from its point of declaration up until the end of the enclosing block.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;File scope&lt;/strong&gt;: The object is &amp;ldquo;visible&amp;rdquo; from its point of declaration up until the end of the enclosing file.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Linkeage&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;The linkeage of an object determines to which extent it can be shared among the different &amp;ldquo;files&amp;rdquo; (compilation units) in a program.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;External linkage&lt;/strong&gt;: An object with &lt;em&gt;external linkage&lt;/em&gt; may be shared with multiple files in a program (perhaps all?)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Internal linkage&lt;/strong&gt;: An object with &lt;em&gt;internal linkage&lt;/em&gt; is limited to the file in which it is declared and can not be shared with multiple files in a program.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No linkage&lt;/strong&gt;: An object with no linkage cannot be shared at all, and is only visible inside of the function in which it is declared.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;default-properties&#34;&gt;&lt;strong&gt;Default properties&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;The default properties of objects depend on the location in which they were declared.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;objects declared &lt;em&gt;&lt;strong&gt;inside a block&lt;/strong&gt;&lt;/em&gt; (including a function body):
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;automatic storage duration&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;block scope&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;no linkage&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;objects declared &lt;em&gt;&lt;strong&gt;outside any block&lt;/strong&gt;&lt;/em&gt; (the root of the file):
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;static storage duration&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;file scope&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;external linkage&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;syntax&#34;&gt;&lt;strong&gt;Syntax&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;In &lt;strong&gt;C&lt;/strong&gt;, declarations have the following general syntax:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;declaration-specifiers declarators_and_initializers ;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Declaration specifiers&lt;/strong&gt; describe the properties of the objects/functions being declared, while &lt;strong&gt;declarators&lt;/strong&gt; give them names and provide some additional properties.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Declaration specifiers&lt;/strong&gt;&lt;/em&gt; (4 categories):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Storage classes&lt;/strong&gt;: There are (4) of them: &lt;code&gt;auto, static, extern, register&lt;/code&gt;. At most one can be present in a declaration, and if so, it should come first.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Type qualifiers&lt;/strong&gt;: There are (3) of them: &lt;code&gt;const, volatile, restrict&lt;/code&gt;. A declaration may contain zero or more type qualifiers.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Type specifiers&lt;/strong&gt;: &lt;code&gt;void, char, short, int, long, float, double, signed, unsigned&lt;/code&gt;. They may be combined, and the order in which they appear doesn&amp;rsquo;t matter. They also include specifications of &lt;code&gt;structs, unions, and enums&lt;/code&gt;, and names created using &lt;code&gt;typedef&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Function specifier&lt;/strong&gt; (C99 only): &lt;code&gt;inline&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;I won&amp;rsquo;t cover each category of declaration-specifiers separately as it would be too much. Each category and keyword is described thoroughly in &lt;em&gt;Chapter 18&lt;/em&gt; (K.N. King. C).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Declarators&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;They provide the declarations with identifying names, along with additional type information (&lt;code&gt;*, [], etc...&lt;/code&gt; for for pointers and array types).&lt;/li&gt;
&lt;li&gt;They may be accompanied by initializers.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;union, struct, and enum&lt;/code&gt; declarations can omit the declarators, in which case they declare just the tag and/or enum constant (as an either complete or incomplete type)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>The 0xFFFFFFFF problem</title>
      <link>https://bool3max.github.io/posts/int_problem/</link>
      <pubDate>Thu, 13 Sep 2018 02:51:42 +0200</pubDate>
      
      <guid>https://bool3max.github.io/posts/int_problem/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;This is a pretty old document that I wrote for myself back when I was first learning C, but the explanation is pretty good so I published it here for future reference. I hope to soon push a reference document that explains some tricky concepts and things from the C standard that are not so easy to remember off the top of the head (such as type conversion, declarations, storage durations, scopes, etc&amp;hellip;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;For future reference, always refer to the latest C standard as it has answers to many questions of the same nature such as this one. The C11 draft can be found &lt;a href=&#34;https://port70.net/~nsz/c/c11/n1570.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Recently, I posted &lt;a href=&#34;https://stackoverflow.com/questions/51160300/why-do-c-compilers-not-warn-when-assigning-integer-value-too-high-for-signed-typ?noredirect=1#comment89304841_51160300&#34;&gt;this question to StackOverflow&lt;/a&gt; about the following program:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xFFFFFFFF&lt;/span&gt;;
    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, n); &lt;span style=&#34;color:#75715e&#34;&gt;//was originaly %u
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this explanation, I will disregard the fact that I used the wrong conversion specifier in my &lt;code&gt;printf&lt;/code&gt; call (used &lt;code&gt;%u&lt;/code&gt; instead of &lt;code&gt;%d&lt;/code&gt;), thus I will replace it with the correct one, and will come back to the topic of &lt;code&gt;%u&lt;/code&gt; later on in the explanation.&lt;/p&gt;
&lt;p&gt;So, what exactly is happening here? Initially, I was confused as to why this program&amp;rsquo;s output was &lt;code&gt;-1&lt;/code&gt; (at least on a linux/gcc 64bit platform).&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s break the &amp;ldquo;problem&amp;rdquo; down into pieces and analyze each statement and operand separately:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The hexadecimal constant &lt;code&gt;0xFFFFFFFF&lt;/code&gt;, is in decimal form equal to &lt;code&gt;2 ^ 32 - 1&lt;/code&gt;, or &lt;code&gt;4294967295&lt;/code&gt;, and in binary form, equal to &lt;code&gt;11111111111111111111111111111111&lt;/code&gt;. By the compiler, &lt;strong&gt;it is treated as an &lt;em&gt;unsigned integer&lt;/em&gt;&lt;/strong&gt;, and not as a series of bits. Yes, it can be represented as a series of 32 bits &lt;em&gt;(all 1&amp;rsquo;s)&lt;/em&gt;, but to the compiler that is apparently irrelevant. In C99, hexadecimal and octal constants are tested in the following order:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int&lt;/li&gt;
&lt;li&gt;unsigned int&lt;/li&gt;
&lt;li&gt;long int&lt;/li&gt;
&lt;li&gt;unsigned long int&lt;/li&gt;
&lt;li&gt;long long int&lt;/li&gt;
&lt;li&gt;unsigned long long int&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first type that is large enough to accomodate the size of the constant is the one that the compiler will use to identify it.
In this case, &lt;code&gt;0xFFFFFFFF&lt;/code&gt; is too large to fit in the first contender (&lt;code&gt;int&lt;/code&gt;, or rather &lt;code&gt;signed int&lt;/code&gt;), but is just the right size to be treated as an &lt;code&gt;unsigned int&lt;/code&gt;, and thus the compiler treats it as that.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Next, let&amp;rsquo;s look at the left operand of the &lt;code&gt;=&lt;/code&gt; operator, &lt;code&gt;int&lt;/code&gt;. When used by itself, it is the equivalent of &lt;code&gt;singed int&lt;/code&gt;, and thus I will refer to it as that from now on. The largest positive number that a &lt;code&gt;signed int&lt;/code&gt; can store is equal to &lt;code&gt;2 ^ 31 - 1&lt;/code&gt;, or &lt;code&gt;2147483647&lt;/code&gt; in decimal form, due to the need of being able to represent negative integers, and thus having one less bit to work with.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The types of the operands on both sides of the &lt;code&gt;=&lt;/code&gt; operator &lt;strong&gt;don&amp;rsquo;t match&lt;/strong&gt;. One is a &lt;code&gt;signed int&lt;/code&gt;, the other an &lt;code&gt;unsigned int&lt;/code&gt;. Thus, C has to &lt;em&gt;implicitly&lt;/em&gt; convert the right operant &lt;em&gt;to the type of the left operand&lt;/em&gt;. (in assignment, &lt;strong&gt;the right operand always has to abide by the type of the left one&lt;/strong&gt;). The result of this conversion isn&amp;rsquo;t specified in the C standard, and is therefore implemenation defined.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Per my current understanding, the binary representation of &lt;code&gt;0xFFFFFFFF&lt;/code&gt;, or rather &lt;code&gt;0b11111111111111111111111111111111&lt;/code&gt; is simply copied into the address of our &lt;code&gt;signed int n&lt;/code&gt; varible. Since the variable is a &lt;code&gt;signed integer&lt;/code&gt;, it utilizes &lt;strong&gt;2&amp;rsquo;s complement&lt;/strong&gt;. In 2&amp;rsquo;s complement, a binary representation of &lt;strong&gt;all 1s&lt;/strong&gt; is always equal to &lt;em&gt;&lt;strong&gt;-1&lt;/strong&gt;&lt;/em&gt; in decimal form, and therefore &lt;em&gt;&lt;strong&gt;that is the output of our printf() call&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Why are all 1s always equal to -1 (decimal) in 2&amp;rsquo;s complement? Let&amp;rsquo;s look at the following example using an 8bit number (although the same rules apply for any other number of bits, &lt;em&gt;including 32&lt;/em&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;in a regular unsigned system, 1 (decimal) is equal to &lt;code&gt;0b00000001&lt;/code&gt; in binary. Very obvious.&lt;/li&gt;
&lt;li&gt;Let&amp;rsquo;s get the negative value of this number (-1) using the 2s complement operation:
&lt;ul&gt;
&lt;li&gt;first we invert the bits: &lt;code&gt;0b00000001&lt;/code&gt; -&amp;gt; &lt;code&gt;0b11111110&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;then we add 1        : &lt;code&gt;0b11111110&lt;/code&gt; -&amp;gt; &lt;code&gt;0b11111111&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Upon completion of the 2s complement operation, we ended up with a binary representation of the negative version of our original number (-1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;As you can see, we&amp;rsquo;ve ended up with the number -1 (decimal), that is in binary equal to all 1s (all bits). The same is true when the operation is applied to a number consisting of any number of bits.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;the-u-problem&#34;&gt;The &lt;code&gt;%u&lt;/code&gt; problem&lt;/h2&gt;
&lt;p&gt;As I said, in my original question I (for some unknown reason?) substituted the &lt;code&gt;%d&lt;/code&gt; conversion specifier with the &lt;code&gt;%u&lt;/code&gt; conversion specifier, resulting in the following statement:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%u&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, n);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This statement prints out &lt;code&gt;4294967295&lt;/code&gt;. Why? Let&amp;rsquo;s find out:&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;%u&lt;/code&gt; conversion expects an unsigned integer as the argument. We&amp;rsquo;ve, however, supplied it a &lt;em&gt;singed&lt;/em&gt; integer. However, this time there is no conversion, as the conversion from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;unsigned int&lt;/code&gt; is impossible, nonexistent, and therefore the behaviour is undefined.&lt;/p&gt;
&lt;p&gt;In the case of GCC, &lt;code&gt;%u&lt;/code&gt; (or rather, &lt;code&gt;printf&lt;/code&gt;) &lt;em&gt;assumes&lt;/em&gt; that the value passed to it is of the correct type (&lt;code&gt;uint&lt;/code&gt; in this case), and prints its value accordingly. &lt;code&gt;0xFFFFFFFF&lt;/code&gt; in an unsigned system has the decimal value &lt;em&gt;4294967295&lt;/em&gt;, which is then simply printed.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>